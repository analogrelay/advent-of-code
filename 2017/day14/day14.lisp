(load "../day10/day10.lisp")

(defun set-bits (val offset array)
  (dotimes (bit 8)
    (setf (elt array (+ (* offset 8) (- 7 bit))) (logand (ash val (- bit)) 1))))

(defun to-bit-array (seq)
  (let ((arr (make-array (* (length seq) 8) :element-type 'bit :initial-element 0)))
    (dotimes (i (length seq))
      (set-bits (elt seq i) i arr))
    arr))

(defun render-row (bits)
  (dotimes (i (length bits))
    (case (elt bits i)
      (1 (format t "#"))
      (0 (format t ".")))))

(defun get-row-key (key row)
  (concatenate 'string key (format nil "-~a" row)))

(defun generate-memory (key rows)
  (let ((arr (make-array (* rows 16 8) :element-type 'bit :initial-element 0)))
    (dotimes (row rows)
      (let ((val (knot-hash (get-row-key key row))))
	(dotimes (i 16)
	  (set-bits (elt val i) (+ (* row 16) i) arr))))
    arr))
	
(defun run-day14a (input)
  (count 1 (generate-memory input 128)))

(defun next-offset (idx len stride direction)
  (case direction
    (:n (when (> idx stride) (- idx stride)))
    (:s (when (< (+ idx stride) len) (+ idx stride)))
    (:e (unless (= (mod idx stride) (1- stride)) (1+ idx)))
    (:w (unless (= (mod idx stride) 0) (1- idx)))))

(defun flood-clear (idx array stride)
  (when (and (>= idx 0) (< idx (length array)) (= (elt array idx) 1))
    ;;(format t "clearing ~a,~a~%" (mod idx stride) (floor (/ idx stride)))
    (setf (elt array idx) 0)
    (let ((n (next-offset idx (length array) stride :n))
	  (e (next-offset idx (length array) stride :e))
	  (s (next-offset idx (length array) stride :s))
	  (w (next-offset idx (length array) stride :w)))
      (when n (flood-clear n array stride))
      (when e (flood-clear e array stride))
      (when s (flood-clear s array stride))
      (when w (flood-clear w array stride)))))

(defun render-grid (grid stride)
  (dotimes (row (/ (length grid) stride))
    (dotimes (col stride)
      (if (= (elt grid (+ (* row stride) col)) 1)
	  (format t "#")
	  (format t ".")))
    (format t "~%")))

(defun count-regions (array stride)
  (do ((candidate (position 1 array) (position 1 array))
       (count 0 (1+ count)))
      ((not candidate) count)
    ;;(format t "flood-clearing ~a,~a~%" (mod candidate stride) (floor (/ candidate stride)))
    (flood-clear candidate array stride)))

(defun run-day14b (input)
  (let ((mem (generate-memory input 128)))
    (count-regions mem 128)))
