(load "../day10/day10.lisp")

(defun set-bits (val offset array)
  (dotimes (bit 8)
    (setf (elt array (+ (* offset 8) (- 7 bit))) (logand (ash val (- bit)) 1))))

(defun to-bit-array (seq)
  (let ((arr (make-array (* (length seq) 8) :element-type 'bit :initial-element 0)))
    (dotimes (i (length seq))
      (set-bits (elt seq i) i arr))
    arr))

(defun render-row (bits)
  (dotimes (i (length bits))
    (case (elt bits i)
      (1 (format t "#"))
      (0 (format t ".")))))

(defun get-row-key (key row)
  (concatenate 'string key (format nil "-~a" row)))

(defun generate-memory (key rows)
  (let ((arr (make-array (* rows 16 8) :element-type 'bit :initial-element 0)))
    (dotimes (row rows)
      (let ((val (knot-hash (get-row-key key row))))
	(dotimes (i 16)
	  (set-bits (elt val i) (+ (* row 16) i) arr))))
    arr))
	
(defun run-day14a (input)
  (count 1 (generate-memory input 128)))

(defun get-offset (stride direction)
  (case direction
    (:n (- stride))
    (:s stride)
    (:e -1)
    (:w 1)))

(defun flood-clear (idx array stride)
  (when (and (>= idx 0) (< idx (length array)) (= (elt array idx) 1))
    (setf (elt array idx) 0)
    (flood-clear (+ idx (get-offset stride :n)) array stride)
    (flood-clear (+ idx (get-offset stride :e)) array stride)
    (flood-clear (+ idx (get-offset stride :s)) array stride)
    (flood-clear (+ idx (get-offset stride :w)) array stride)))

(defun render-grid (grid stride)
  (dotimes (row (/ (length grid) stride))
    (dotimes (col stride)
      (if (= (elt grid (+ (* row stride) col)) 1)
	  (format t "#")
	  (format t ".")))
    (format t "~%")))

(defun count-regions (array stride)
  (do ((candidate (position 1 array) (position 1 array))
       (count 0 (1+ count)))
      ((not candidate) count)
    (flood-clear candidate array stride)))

(defun run-day14b (input)
  (let ((mem (generate-memory input 128)))
    (count-regions mem 128)
    (render-grid mem 128)))
