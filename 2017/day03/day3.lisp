(defun coord (x y)
  (list :x x :y y))

(defun get-root-coord (root)
  (if (eql root 1)
      (coord 0 0)
      (if (eql root 2)
	  (coord -1 -1)
	  (let ((half-root (floor (/ root 2))))
	    (if (eql (mod root 2) 0)
		(coord (- (1- half-root)) (- half-root))
		(coord half-root half-root))))))
	
(defun find-roots (val)
  (let ((sq (sqrt val)))
    (list (floor sq) (ceiling sq))))

(defun closest-root (roots val)
  (destructuring-bind (lo hi) roots
    (let ((losq (* lo lo))
	  (hisq (* hi hi)))
      (if (eql val hisq)
	  (list hi (coord 0 0))
	  (let ((lo-break (+ losq (floor (/ (- hisq losq) 2)))))
	    (if (oddp lo)
		(if (> val lo-break) (list hi (coord (- hisq val) 0))
		    (list lo (coord 1 (1+ (- (- val losq))))))
		(if (> val lo-break)
		    (list hi (coord (- (- hisq val)) 0))
		    (list lo (coord -1 (1- (- val losq)))))))))))

(defun get-coord (val)
  (destructuring-bind (root dist) (closest-root (find-roots val) val)
    (coord+ (get-root-coord root) dist)))

(defun coord+ (c1 c2)
  (let ((c1x (getf c1 :x))
	(c1y (getf c1 :y))
	(c2x (getf c2 :x))
	(c2y (getf c2 :y)))
    (coord (+ c1x c2x) (+ c1y c2y))))


(defun coord- (c1 c2)
  (let ((c1x (getf c1 :x))
	(c1y (getf c1 :y))
	(c2x (getf c2 :x))
	(c2y (getf c2 :y)))
    (coord (- c1x c2x) (- c1y c2y))))

(defun run-day3a (input)
  (let ((c (coord- (get-coord input) (coord 0 0))))
    (let ((x (getf c :x))
	  (y (getf c :y)))
      (+ (abs x) (abs y)))))

;;; Part B is pretty different, but we can use some of the stuff from it
(defun generate-ring (index)
  (let ((items nil)
	(span (1+ (* 2 index))))
    (dotimes (i (1- span))
      (push (coord index (- index (1+ i))) items))
    (dotimes (i (1- span))
      (push (coord (- index (1+ i)) (- index)) items))
    (dotimes (i (1- span))
      (push (coord (- index) (+ (- index) (1+ i))) items))
    (dotimes (i (1- span))
      (push (coord (+ (- index) (1+ i)) index) items))
    (nreverse items)))

(defun get-adjacent (coord)
  (let ((cx (getf coord :x))
	(cy (getf coord :y)))
    (list
     (coord (1+ cx) cy)
     (coord (1+ cx) (1- cy))
     (coord cx (1- cy))
     (coord (1- cx) (1- cy))
     (coord (1- cx) cy)
     (coord (1- cx) (1+ cy))
     (coord cx (1+ cy))
     (coord (1+ cx) (1+ cy)))))

(defun make-mem () (make-hash-table :test #'equal))
(defun get-val (coord mem)
  (let ((result (or (gethash coord mem) 0)))
    (format t " ~a == ~a~%" coord result)
    result))
(defun set-val (coord val mem) (setf (gethash coord mem) val))

(defun get-val-for-cell (coord mem)
  (reduce #'+ (mapcar (lambda (x) (get-val x mem)) (get-adjacent coord))))

(defun run-day3b (input)
  (let ((mem (make-mem)))
    (set-val (coord 0 0) 1 mem)
    (do ((ring 1 (1+ ring)))
	(nil nil) ; Infinite loop
      (dolist (c (generate-ring ring))
	(let ((val (get-val-for-cell c mem)))
	  (format t "setting ~a to ~a~%" c val)
	  (when (> val input) (return-from run-day3b val))
	  (set-val c val mem))))))
